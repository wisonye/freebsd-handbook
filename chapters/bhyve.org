* Bhyve Virtualization in =FreeBSD=

=bhyve= is the hyprvisor in =FreeBSD=, and =vm_bhyve= is a frontend for =bhyve= which provides the =vm= command to manage the =bhyve= virtual machines.

** Install and setup

#+BEGIN_SRC bash
   #
   # `grub2-bhyve`: If want Linux guest
   # `bhyve-firmware`: If you want UEFI and VNC graphic support
   #
   doas pkg install vm-bhyve-devel grub2-bhyve bhyve-firmware

   # 
   # Create a new ZFS dataset to hold all VM files
   # 
   doas zfs create -o mountpoint=/home/$USER/vm zroot/vm
   doas chown -R $USER:$USER ~/vm/

   #
   # Load all related modules and settings
   #
   doas sysrc vmm_enable=YES
   doas sysrc vm_enable=YES
   doas sysrc vm_dir="zfs:zroot/vm"
#+END_SRC


** =vm init= and =tmux=

=vm init= needs be run once after host reboot before running any other =vm= commands. The main function of the =init= command is as follows:

o Load all necessary kernel modules if not already loaded
o Set tap devices to come up automatically when opened
o Create any configured virtual switches


=vm init= also create subdirectories inside =$vm_dir= to hold configuration and templates:

#+BEGIN_SRC bash
  ls -lhta ~/vm

  # total 11
  # drwxr-xr-x   2 root  wison    4B Feb 21 16:37 .config/
  # drwxr-xr-x   2 root  wison    3B Feb 21 15:44 .templates/
  # drwxr-xr-x   6 wison wison    6B Feb 21 15:44 ./
  # drwxr-xr-x   2 root  wison    2B Feb 21 15:44 .img/
  # drwxr-xr-x   2 root  wison    2B Feb 21 15:44 .iso/
  # drwxr-xr-x  22 wison wison   54B Feb 21 15:41 ../
#+END_SRC


By default, =vm-bhyve= uses =cu/nmdm= as a console session management tool. If you prefer to run virtual machines on a =tmux= session instead, this is now supported in v1.1+. All you need to do is to set console option in =$vm_dir/.config/system.conf=:

#+BEGIN_SRC bash
  vm set console=tmux
#+END_SRC

Once set, any new guests started will have a =tmux= session associated with them. The session name is the same as the guest name, although you can also attach it to the tmux session using the standard =vm console guest= command.

For example:

#+BEGIN_SRC bash
  #
  # vm list |grep fbsd
  #
  fbsd            default         bhyveload   2      256M      -                    No           Running (88761)

  #
  # tmux ls
  #
  fbsd: 1 windows (created Tue Jun 28 10:42:22 2016) [168x46]
#+END_SRC


So, you can use ~tmux attach-session -t fbsd~ and do a quick switch between different tmux sessions.


** Create virtual switch and attach your NIC to it

The =vm= utility automatically creates a =bridge= device for each =virtual switch=. When a guset is started, a virtual ethernet (=tap=) device is created, and it will be automatically added as a member of the specified =virtual switch=.


*** Create a standard type virtual switch

You're able to bind the virtual switch to multiple NICs.

- =-t=: Specify virtual switch type, =standard= is the default value if you don't provided.
- =-i=: Attach a physical NIC. You can't use =i= more than once!!!
- =-a=: Specify an IP adress that is assigned to the bridge interface.
- =-p=: Enable private mode, guests can't access each other, even they're conntected the same virtual switch!!!
- =internal=: The name of virtual switch, maximum length of a switch name is also limited to 12 characters.

#+BEGIN_SRC bash
  doas vm switch create \
      -t standard \
      -i igc0 \
      -a 192.168.2.1/24 \
      internal
#+END_SRC


Plz DO NOT attach more than one physical interface to the virtual switch, otherwise, it caused internet access issue!!!

**** Alternative way to create

You can separate the above command to the following commands for doing the same thing:

#+BEGIN_SRC bash
  doas vm switch create internal
  doas vm switch address internal 192.168.2.1/24
  doas vm switch add internal igc0
  # doas vm switch add internal wlan0

  #
  # Turn on/off the private mode on a switch
  #
  doas vm switch private internal on
  doas vm switch private internal off
#+END_SRC

Also, that's how you can modify the created virtual switch settings as well.


*** List and info

#+BEGIN_SRC bash
  doas vm switch list
  # NAME      TYPE      IFACE        ADDRESS         PRIVATE  MTU  VLAN  PORTS
  # internal  standard  vm-internal  192.168.2.1/24  no       -    -     igc0 wlan0

  doas vm switch info internal
  # ------------------------
  # Virtual Switch: internal
  # ------------------------
  #   type: standard
  #   ident: vm-internal
  #   vlan: -
  #   physical-ports: igc0 wlan0
  #   bytes-in: 350864 (342.640K)
  #   bytes-out: 298315 (291.323K) 
#+END_SRC


*** What actual change on the host

When you created a virtual switch, you can see =ifconfig= list a new bridge NIC like this:

The new NIC's name will be =vm-YOUR_VIRTUAL_SWITCH_NAME=

#+BEGIN_SRC bash
vm-internal: flags=1008843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST,LOWER_UP> metric 0 mtu 1500
        options=0
        ether 26:d5:e0:84:0b:5e
        inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 2000 timeout 1200
        root id 00:00:00:00:00:00 priority 32768 ifcost 0 port 0
        member: igc0 flags=143<LEARNING,DISCOVER,AUTOEDGE,AUTOPTP>
                ifmaxaddr 0 port 1 priority 128 path cost 20000
        groups: bridge vm-switch viid-d1efa@
        nd6 options=9<PERFORMNUD,IFDISABLED>
#+END_SRC


Also, new rules are added to routing table:

#+BEGIN_SRC bash
  netstat  -rn4

  # Routing tables
  # 
  # Internet:
  # Destination        Gateway            Flags     Netif Expire
  # default            192.168.1.200      UGS        igc0
  # 127.0.0.1          link#2             UH          lo0
  # 192.168.1.0/24     link#3             U         wlan0
  # 192.168.1.160      link#2             UHS         lo0
  # 192.168.1.190      link#2             UHS         lo0
  192.168.2.0/24     link#5             U      vm-inter
  192.168.2.1        link#2             UHS         lo0 
#+END_SRC


*** Virtual switch configuration file

#+BEGIN_SRC bash
  cat ~/vm/.config/system.conf

  # vm set console=tmux
  # switch_list="internal"
  # type_internal="standard"
  # ports_internal="igc0 wlan0"
  # addr_internal="192.168.2.1/24" 
#+END_SRC


*** How to switch physical interface for the given virtual switch

For example, my =TH80= both connect =wlan0= for WIFI and =igc0= Ethernet (as the default gateway), but I attach =igc0= when creating =internal= virtual switch.

So, when I unplug the ethernet cable and reboot, =FreeBSD= will switch the default gateway to =wlan0= automatically. But the =internal= virtaul switch won't be able to access internet, as it binds to =igc0= when created!!

So, I have to do the following between switching physical NICs:

#+BEGIN_SRC bash
  #
  # If I use Ethernet
  #
  doas vm switch remove internal wlan0
  doas vm switch add internal igc0

  #
  # If I use WIFI
  #
  doas vm switch remove internal igc0
  doas vm switch add internal wlan0
#+END_SRC


** NAT feature on virtual switch

Unfortunately, internal =NAT= configuration has been removed as of =v1.2=. As a shell script, we relied on configuring external systems such as =pf= and =dnsmasq= to provide =NAT= functions. Some users want to use other tools/firewalls, and many users found =NAT= broken due to existing pf or =dnsmasq= configuration they had in place.

That said, you better to manually configure =NAT= rather than to try and enable it via =vm-bhyve=, it's not that difficult than you think:)

https://github.com/churchers/vm-bhyve/wiki/NAT-Configuration


** Download ISO

You can  run =doas vm ISO_LINK_URL_HERE= to downlaod the ISO file or download somewhere else (get the benefit from mirror site) and then move it into ~$vm_dir/.iso~ folder.

After that, you can run =doas vm iso= to list all downloaded ISOs:

#+BEGIN_SRC bash
  doas vm iso
  # DATASTORE           FILENAME
  # default             Fedora-Everything-netinst-x86_64-39-1.5.iso
#+END_SRC


** Create guest configuration 

All available settings are in =/usr/local/share/examples/vm-bhyve/config.sample=. You better to modify on top of the existing pre-configed template!!!

You should copy one of them, modify it and save to =$vm_dir/.template=.


** Create guest VM

=-t arch_linux=: Use =$vm_dir/.template/arch_linux.conf= as template to create VM
=-s 20GB=: Init 20GB virtual disk, override the =disk0.size= in config file
=my-arch=: VM name

#+BEGIN_SRC bash
  #
  # Create VM, just created, not start the vm at all!!!
  #
  doas vm create -t arch_linux my-arch

  #
  # List created VM
  #
  doas vm list
  # NAME     DATASTORE  LOADER  CPU  MEMORY  VNC  AUTO  STATE
  # my-arch  default    uefi    16   16G     -    No    Stopped

  #
  # Here is where the VM located
  #
  ls -lht ~/vm/my-arch/
  # -rw-r--r--  1 root wheel  2.7K Mar 17 12:33 my-arch.conf
  # -rw-------  1 root wheel   30G Mar 17 12:33 disk0.img
  # -rw-r--r--  1 root wheel   92B Mar 17 12:33 vm-bhyve.log
#+END_SRC


=~/vm/my-arch/my-arch.conf= is a copy of the given template with the newly added =uuid= and unique NIC mac address:

#+BEGIN_SRC bash
  bat ~/vm/my-arch/my-arch.conf

  # loader="uefi"
  # cpu=16
  # memory=16G
  # network0_type="virtio-net"
  # network0_switch="public"
  # disk0_type="virtio-blk"
  # disk0_name="disk0.img"
  # graphics="yes"
  # graphics_port="5999"
  # graphics_res="1600x1200"
  # graphics_wait="auto"
  # xhci_mouse="yes"
  # uuid="9ec2dd39-e3ed-11ee-997c-5847ca7014b5"
  # network0_mac="58:9c:fc:02:33:f4"
#+END_SRC


Also, you can list the vm info like this:

#+BEGIN_SRC bash
  doas vm info my-arch
  # ------------------------
  # Virtual Machine: my-arch
  # ------------------------
  #   state: stopped
  #   datastore: default
  #   loader: grub
  #   uuid: 9ec2dd39-e3ed-11ee-997c-5847ca7014b5
  #   cpu: 16
  #   memory: 16G
  # 
  #   network-interface
  #     number: 0
  #     emulation: virtio-net
  #     virtual-switch: internal
  #     fixed-mac-address: 58:9c:fc:02:33:f4
  #     fixed-device: -
  # 
  #   virtual-disk
  #     number: 0
  #     device-type: file
  #     emulation: virtio-blk
  #     options: -
  #     system-path: /home/wison/vm/my-arch/disk0.img
  #     bytes-size: 32212254720 (30.000G)
  #     bytes-used: 1024 (1.000K)
#+END_SRC


If you want to re-create a VM, you can run ~doas vm destroy my-arch~ to delete it and re-create again.


** Launch the guest installation process

First, you need a VNC client to connecto the guest VNC server, let's install it:

#+BEGIN_SRC bash
  #
  # `wlvncc`: A work-in-progress implementation of a Wayland native VNC client. 
  #
  doas pkg install wlvncc
#+END_SRC

Now, let's install Arch Linux:

#+BEGIN_SRC bash
  #
  # `-f`: Guest will be started in the foreground on stdio. 
  #
  doas vm install -f my-arch archlinux-2024.03.01-x86_64.iso
#+END_SRC


After that, list the VNC port and connect to it to finish the installation process:

#+BEGIN_SRC bash
  #
  # List guest vnc port
  #
  doas vm list
  # NAME     DATASTORE  LOADER  CPU  MEMORY  VNC           AUTO  STATE
  # my-arch  default    uefi    16   16G     0.0.0.0:5999  No    Locked (th80)

  #
  # Connect to it (as it will wait for the VNC connect before ISO boot)
  #
  wlvncc 127.0.0.1 5999
#+END_SRC


** Run and stop and related VM stuff

If you're currently inside a tmux session, then you HAVE TO detech or open a new terminal before running the following command, as it will start a new tmux and attach into it immediately.

#+BEGIN_SRC bash
  #
  # `-f`: Guest will be started in the foreground on stdio. 
  # `-i`: Starts the guest in interactive mode on a foreground tmux session. 
  #
  doas vm start -fi my-arch
  doas vm stop my-arch

  #
  # Force to power off when needed
  #
  doas vm poweroff -f my-arch
#+END_SRC



** Firewall setup

If your host uses =PF=, then you have to modify =PF= rules to make the VM network work, here the newly added rules target the VM in =/etc/pf.conf=:

#+BEGIN_SRC bash
  nic_vm_switch = "vm-internal"
  nic_vm_group = "vm-switch"
  trust_vm_node = "{192.168.2.10, 192.168.2.20}"

  # ==============================================================================
  #
  # Allow {DNS,NTP,Multicast DNS, SSDP} query & response (statefully by default)
  #
  # DNS  - Domain Name Server (53 UDP)
  # NTP  - Network Time Protocol (123 UDP)
  # mdsn - Multicast DNS (5353 UDP)
  # SSDP - Selective Service Discovery Protocol (1900 UDP)
  # BOOT/DHCP - Bootstrap Protocol (BOOTP) (legacy BOOTP functionality by DHCP)
  #
  # ==============================================================================
  pass quick on $nic_vm_group proto udp from any to any port {domain,ntp,mdns,ssdp,bootpc}

  # ==============================================================================
  #
  # - Allow out ping request and reply (statefully by default)
  # - Allow trust node ping me
  # - Allow trust vm node ping me
  #
  # - `inet`:
  #   It's the optional `address family` value, it means `ipv4`.
  #   `inet6` means `ipv6`.
  #
  # - In the `from ⟨source⟩ port ⟨source⟩ os ⟨source⟩ to ⟨dest⟩ port ⟨dest⟩` part:
  #
  # 	`all` - This is equivalent to `from any to any`
  #
  # - For knowing the `icmp-type` name and number: `man icmp`
  #
  # ==============================================================================
  pass in quick on $nic_vm_group proto icmp from $trust_vm_node to {($nic_vm_switch)} icmp-type echoreq

  # ==============================================================================
  #
  # - Allow me to ssh to vm
  #
  # ==============================================================================
  pass in quick on $nic_vm_group proto tcp from {($nic_vm_switch)} to $trust_vm_node port ssh

  # ==============================================================================
  #
  # Allow dialy app to use: all outgoing TCP and related reply
  #
  # ==============================================================================
  pass out quick on $nic_vm_group proto tcp from {($nic_vm_switch)} to any

  # Youtube needed
  # https       443/udp
  # ssdp        1900/udp   #Selective Service Discovery Protocol (UPnP)
  pass out quick on $nic_vm_group proto udp from {($nic_vm_switch)} to any port {https,ssdp}

  # ==============================================================================
  #
  # Last step before `block all`:
  #
  # Block and log all incoming and outgoing packets via default out NIC and either:
  #
  # - Want to go out from my ip
  # - Want to come in to my ip
  #
  # The purpose for those rules is that: 
  #
  # I can review the pflog file to see whether I'missing any allows rules or not:)
  #
  # ==============================================================================
  block in quick log(all) on $nic_vm_group from any to {($nic_vm_switch)}
  block out quick log(all) on $nic_vm_group from {($nic_vm_switch)} to any
#+END_SRC
